#!/usr/bin/gawk -f
function inArray(needle, haystack,   x, y) {
  for (x in haystack) y[haystack[x]]
  return(needle in y)
}

## check if a file exists (and can be read)
function exists(file,   junk) {
   if ( (getline junk < file) > 0 ) {
      close (file)
      return 1
   }
   return 0
}

## prints a timestamped message if the configured debug level is high enough
## Usage: dbg(4, "callingFunction", "message")
function dbg(level, fnc, msg,   fncs) {
  # only debug functions configured in config["debugfnc"]
  if (config["debugfnc"]) {
    split(tolower(config["debugfnc"]), fncs, ",")
    if ( (config["debuglvl"] >= level) && inArray(tolower(fnc), fncs) )
      printf("[%s] %-5s: %s(): %s\n", strftime("%T"), debug[level], fnc, msg)
  } else {
    # if no config["debugfnc"] is defined do everything
    if (config["debuglvl"] >= level)
      printf("[%s] %-5s: %s(): %s\n", strftime("%T"), debug[level], fnc, msg)
  }
}

## return if userhost is part of a group (admin|oper|friend)
## Usage: isPartOf("nick!user@domain.com", "group1|group2")
function isPartOf(userhost, grps,   i, u, usr, g, grp) {
  u = tolower(userhost)
  dbg(5, "isPartOf", sprintf("u = \"%s\" (%s), grps = \"%s\"", u, userhost, grps))

  # split grps to array (separator "|")
  if (split(grps, grp, "|") > 0) {
    for (g in grp) {
      # split groups[] into usr elements
      dbg(5, "isPartOf", sprintf("grp = \"%s\" (%s)", grp[g], groups[grp[g]]))
      if (split(tolower(groups[grp[g]]), usr, " ") > 0) {
        for (i in usr) {
          # match userhost to usr from groups[]
          dbg(5, "isPartOf", sprintf("usr[%s] = \"%s\"", i, usr[i]))
          if (u ~ usr[i]) {
            # there is a match
            dbg(4, "isPartOf", sprintf("\"%s\" =~ \"%s\"", u, usr[i]))
            return(1)
          }
        }
      }
    }
  }

  # this user is not part of any of the groups
  dbg(4, "isPartOf", sprintf("\"%s\" no match", u, usr[i]))
  return(0)
}

# $U = usermask (nick!login@host)
# $N = nick
# $A = auth
# $H = host
# $C = channel
# $T = target (either nick or channel)
# $I = IRC action
# $M = message (complete)
# $c = bot command
# $m = message (without command)
# $1-$9 = first 9 words of (short) message
function vsub(msg) {
  dbg(4, "vsub", sprintf("pre msg=\"%s\"", msg))
  gsub(/\$U/, var["user"], msg)
  gsub(/\$N/, var["nick"], msg)
  gsub(/\$A/, var["auth"], msg)
  gsub(/\$H/, var["host"], msg)
  gsub(/\$T/, var["target"], msg)
  gsub(/\$I/, var["action"], msg)
  gsub(/\$C/, var["channel"], msg)
  gsub(/\$M/, var["msg"], msg)
  gsub(/\$c/, var["cmd"], msg)
  gsub(/\$m/, var["args"], msg)
  gsub(/\$1/, varmsg[1], msg)
  gsub(/\$2/, varmsg[2], msg)
  gsub(/\$3/, varmsg[3], msg)
  gsub(/\$4/, varmsg[4], msg)
  gsub(/\$5/, varmsg[5], msg)
  gsub(/\$6/, varmsg[6], msg)
  gsub(/\$7/, varmsg[7], msg)
  gsub(/\$8/, varmsg[8], msg)
  gsub(/\$9/, varmsg[9], msg)
  dbg(4, "vsub", sprintf("post msg=\"%s\"", msg))

  return(msg)
}

## tokenize a file based on the following parser
## ON <action> [FROM "%"<group>|<nick>["!"<auth>"@"<host>]] [TO "#"<channel>|<nick>] [SAYING <contents>] DO <command>;

function tokenize(file, tokens,   line, lnr, nrlines, token) {
  dbg(4, "tokenize", sprintf("file: \"%s\"", file))
  IGNORECASE = 1

  lnr = 0
  while ( (getline line < file) > 0 ) {
    lnr++
    dbg(5, "tokenize", sprintf("line #%d: \"%s\"", lnr, line))
    if ( match(line, /^ON ("[^"]+|[^ ]+) (FROM ("[^"]+"|[^ ]+) )?(TO ("[^"]+"|[^ ]+) )?(SAYING ("[^"]+"|[^ ]+) )?DO ("[^"]+"|[^ ]+)/, token) ) {
      nrlines++
      gsub(/^\s*"|"\s*$/, "", token[1])
      gsub(/^\s*"|"\s*$/, "", token[3])
      gsub(/^\s*"|"\s*$/, "", token[5])
      gsub(/^\s*"|"\s*$/, "", token[7])
      gsub(/^\s*"|"\s*$/, "", token[8])
      tokens[nrlines] = token[1] "\001" token[3] "\001" token[5] "\001" token[7] "\001" token[8]
      dbg(5, "tokenize", sprintf("ON [%s] FROM [%s] TO [%s] SAYING [%s] DO [%s]", token[1], token[3], token[5], token[7], token[8]))
    } else {
      dbg(2, "tokenize", sprintf("Error parsing line #%d in file \"%s\"", lnr, file))
      dbg(2, "tokenize", sprintf("%s", line))
    }
  }

  close(file)
  IGNORECASE = 0

  return(nrlines)
}


# tries to execute a script and return the results
function dyncommand(plugin, script, message, output,   nrlines, dyndir, exec, maxlines) {
  nrlines = 0;
  # is dyndir absolute or relative
  dyndir = (substr(config["dyndir"], 1, 1) == "/") ? config["dyndir"] : "./"config["dyndir"]

  dbg(4, "dyncommand", sprintf("plugin: \"%s\", script: \"%s\", message: \"%s\"", plugin, script, message))
  # check if plugin and script are configured and exist
  if ( (plugin in plugins) && exists(dyndir"/"script) ) {
    exec = sprintf(plugins[plugin], dyndir"/"script)

    # execute plugin
    dbg(5, "dyncommand", sprintf("print \"%s\" |& \"%s\"", message, exec))
    print message |& exec
    close(exec, "to")

    # read a configured maximum output lines
    maxlines = config["dynmaxlines"] ? config["dynmaxlines"] : 3
    while ( ((exec |& getline) > 0) && (nrlines < maxlines) ) {
      nrlines++
      output[nrlines] = $0
      dbg(5, "dyncommand", sprintf("#%d \"%s\"", nrlines, output[nrlines]))
    }
    close(exec)
  }

  dbg(4, "dyncommand", sprintf("nrlines: %d", nrlines))
  return(nrlines)
}

# ON <action> [FROM <nick>] [TO <#chan>] [SAYING <contents] DO <command>
function reaction(action,   tmp) {
  if (split(action, tmp, "\001") == 5)
    return(sprintf("ON %s%s%s%s DO %s", tmp[1], tmp[2]?" FROM "tmp[2]:"", tmp[3]?" TO "tmp[3]:"", tmp[4]?" SAYING "tmp[4]:"", tmp[5]))
  else {
    dbg(2, "reaction", sprintf("broken action \"%s\"", action))
    return("<BROKEN ACTION>")
  }
}

function action(   act, i, from, to, saying, token, n, tmp) {
  dbg(4, "action", sprintf("processing %d actions", sysvar["actions"]))
  for (act=1; act<=sysvar["actions"]; act++) {
    from = 0
    to = 0
    saying = 0

    if (split(actions[act], token, "\001") == 5) {
      # ON <action>
      if (tolower(token[1]) == tolower(var["action"])) {
        dbg(4, "action", sprintf("Found ON %s", toupper(token[1])))

        # FROM "%"<group>|<nick>["!"<auth>["@"<host>]] (todo: nick!auth@host)
        if (token[2]) {
          dbg(5, "action", sprintf("matching %s against %s", var["user"], token[2]))

          n = split(tolower(token[2]), tmp, "|")
          dbg(5, "action", sprintf("found %d users/groups", n))
          for (i=1; i<=n; i++) {

            if (substr(tmp[i], 1, 1) == "%") {
              dbg(5, "action", sprintf("checking group %s", tmp[i]))
              if (isPartOf(var["user"], substr(tmp[i], 2))) {
                from = 1
                dbg(4, "action", sprintf(" FROM (%s in %s)", var["user"], tmp[i]))
                break
              }
            } else dbg(5, "action", sprintf("unknown FROM %s", tmp[i]))
          } 
        } else from = 1


        # TO "#"<channel>|<nick> (todo: nick)
        if (token[3]) {
          dbg(5, "action", sprintf("matching %s against %s", var["target"], token[3]))

          n = split(tolower(token[3]), tmp, "|")
          dbg(5, "action", sprintf("found %d channels/nicks", n))
          for (i=1; i<=n; i++) {
            if (tolower(var["target"]) == tmp[i]) {
              to = 1
              dbg(4, "action", sprintf(" TO (%s = %s)", var["target"], tmp[i]))
              break
            }
          }
        } else to = 1


        # SAYING <contents>
        if (token[4]) {
          dbg(5, "action", sprintf("matching %s against %s", var["msg"], token[4]))
          if (tolower(var["msg"]) ~ tolower(token[4])) {
            saying = 1
            dbg(4, "action", sprintf(" SAYING (%s = %s)", var["msg"], token[4]))
            break
          }
        } else saying = 1


        if (from && to && saying) {
          a = actions[i]
          gsub("\001", ", ", a)
          dbg(3, "action", sprintf("raw \"%s\" matches action \"%s\"", var["raw"], reaction(actions[act])))
        } else dbg(4, "action", sprintf("Failed%s%s%s", from?"":" FROM", to?"":" TO", saying?"":" SAYING"))
      }
    } else dbg(4, "action", sprintf("broken action #%d", i))
  }
}

## execute/send a basic IRC command to the configured IRC server
## Usage: basiccmd("nick!user@host.com", "command", "args")
function basiccmd(   cmd, plugin, script, line, lines, output) {
  dbg(4, "basiccmd", sprintf("\"%s\" \"%s\" \"%s\"", var["user"], var["cmd"], var["args"]))

  cmd = var["cmd"]
  if (cmd in commands) {
    dbg(5, "basiccmd", sprintf("found command \"%s\"", cmd))
    plugin = substr(commands[cmd], 1, index(commands[cmd], ":")-1)
    script = substr(commands[cmd], index(commands[cmd], ":")+1)

    if (permissions[cmd]) {
      dbg(5, "basiccmd", sprintf("permissions for command \"%s\" are \"%s\"", cmd, permissions[cmd]))
      if (isPartOf(var["user"], permissions[cmd])) {
        dbg(5, "basiccmd", sprintf("user \"%s\" is allowed", var["user"]))
        if (plugin == "irc") print vsub(script)
        else {
          lines = dyncommand(plugin, vsub(script), var["args"], output)
          for (line in output) print vsub(output[line])
        }
      } else dbg(3, "basiccmd", sprintf("\"%s\"; user \"%s\" unauthorized", cmd, var["user"]))
    } else {
      if (plugin == "irc") print vsub(script)
      else {
        lines = dyncommand(plugin, vsub(script), var["args"], output)
        for (line in output) print vsub(output[line])
      }
    }
  } else dbg(3, "basiccmd", sprintf("\"%s\"; Unknown command", cmd))
}

## parse 'raw' output to usable var[]
function parse(raw) {
  var["user"] = raw[1]?raw[1]:"<NONE>"

  if (match(var["user"], /:*(.+)!(.+)@(.+)/, usr)) {
    var["nick"] = usr[1]?usr[1]:"<NONE>"
    var["auth"] = usr[2]?usr[2]:"<NONE>"
    var["host"] = usr[3]?usr[3]:"<NONE>"
  } else var["nick"] = var["auth"] = var["host"] = "<NONE>"

  var["action"] = raw[2]?raw[2]:"<NONE>"
  var["target"] = raw[3]?raw[3]:var["nick"]
  var["channel"] = match(var["target"], /^(#|&)/) ? var["target"] : "<NONE>"
  var["msg"] = raw[4]?raw[4]:"<NONE>"

  # check if this is a command
  if (substr(var["msg"], 1, 1) == config["cmdchar"]) {
    # do we have arguments?
    if ( (i=index(var["msg"], " ")) > 0) {
      var["cmd"] = substr(var["msg"], 2, i-2)
      var["args"] = substr(var["msg"], i+1)
    } else {
      var["cmd"] = substr(var["msg"], 2)
      var["args"] = ""
    }
  }

  # split message into separate words varmsg[]
  split(var["msg"], varmsg, " ")
}


# PRIVMSG channel/nick :message
# PRIVMSG channel/nick :\001CTCP message\001
# TOPIC channel :message
# MODE channel (+|-)modes target1 [target2 [target3]]
# QUIT :message
# NICK nick
# JOIN channel
# PART channel

## returns the systems uptime in seconds with 2 decimal places
function preciseTime() {
  getline < "/proc/uptime";
  close("/proc/uptime");

  return($1);
}

function loadConfig(label,   t1, t2, n, keyval, file) {
  n = 0
  file = config["configdir"] ? config["configdir"]"/"label".cfg" : "./"label".cfg"

  ## start time
  t1 = preciseTime()

  while ((getline < file) > 0) {
    ## skip comments and split key=value pairs
    if ( ($0 !~ /^ *(#|;)/) && (match($0, /([^=]+)=(.+)/, keyval) == 2) ) {
      ## strip leading/trailing spaces and doublequotes
      gsub(/^ *"?|"? *$/, "", keyval[1])
      gsub(/^ *"?|"? *$/, "", keyval[2])
      debug(5, "loadConfig", sprintf("%s[%s]=\"%s\"", label, tolower(keyval[1]), keyval[2]))
      label[tolower(keyval[1])] = keyval[2]
      n++
    }
  }
  close(file)

  t2 = preciseTime();

  debug(3, "loadConfig", sprintf("Loaded %d entries from %s in %.2f seconds\n", n, file, t2-t1))
  return(n)
}

BEGIN {
  # define debug levels
  debug[5] = "DEBUG"
  debug[4] = "INFO"
  debug[3] = "WARN"
  debug[2] = "ERROR"
  debug[1] = "CRIT"
  debug[0] = "LOG"

  # set config options
  config["debuglvl"] = 3
  config["debugfnc"] = "tokenize,action"
  config["cmdchar"] = "!"
  config["dyndir"] = "dyn"
  config["dynmaxlines"] = 5
  config["actionfile"] = "actions.cfg"

  # define groups and their user(mask)s
  groups["admin"] = ".*!patsie@patsie.nl"
  groups["oper"] = ".*!.*user@domain.com .*!.*@domain2.com"
  groups["friend"] = ".*!.*user@domain3.nl .*!.*@domain4.net"

  plugins["awk"] = "/usr/bin/gawk -f %s"
  
  # define commands and what they send to IRC server
  commands["say"] = "irc:PRIVMSG $T :$m"
  commands["ctcp"] = "irc:PRIVMSG $T :\001$m\001"
  commands["topic"] = "irc:TOPIC $T :$m"
  commands["mode"] = "irc:MODE $T $m"
  commands["quit"] = "irc:QUIT :$m"
  commands["nick"] = "irc:NICK $m"
  commands["join"] = "irc:JOIN $m"
  commands["leave"] = "irc:PART $m"
  commands["op"] = "irc:MODE $T +o $N"
  commands["bert"] = "awk:bert.awk"
  commands["test"] = "awk:test.awk"
  commands["shakespear"] = "awk:shakespear.awk"

  # set permissions on certain commands. No permission == all users
  permissions["quit"] = "admin"
  permissions["say"] = "admin|oper"
  permissions["ctcp"] = "admin|oper"
  permissions["mode"] = "admin|oper"
  permissions["nick"] = "admin|oper"
  permissions["join"] = "admin|oper"
  permissions["leave"] = "admin|oper"
  permissions["op"] = "admin|oper|friend"
  permissions["topic"] = "admin|oper|friend"
  permissions["bert"] = "admin|oper|friend"

  timers["topic"] = 60
  timers["op"] = 60

  sysvar["actions"] = tokenize(config["actionfile"], actions)
}

{
  # :user@auth@host COMMAND [target] :message
  if (match($0, /^:([^ ]+) ([0-9A-Z]+) ([^ ]+)? ?:(.*)$/, raw)) {
    var["raw"] = $0
    parse(raw)

  printf("\nraw: \"%s\"\n", var["raw"])
#  printf("user: %s [%s!%s@%s]\n", var["user"], var["nick"], var["auth"], var["host"])
#  printf("target: %s\n", var["target"])
#  printf("action: %s\n", var["action"])
#  printf("message: %s [%s (%s)]\n", var["msg"], var["cmd"], var["args"])
#  printf("words:")
#  for (w in varmsg) printf(" %s:\"%s\"", w, varmsg[w])
#  printf("\n")

    action()
    basiccmd()
  }
}
